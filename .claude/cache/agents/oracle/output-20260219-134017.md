# Research Report: Simulating Keyboard Input to a Running Terminal Process on macOS

Generated: 2026-02-19T13:40:17

## Summary

Writing to `/dev/ttysXXX` (the slave PTY) sends data to the terminal OUTPUT side, not the INPUT side -- this is fundamentally how PTYs work. The master PTY file descriptor is the correct target for injecting input, but it is held privately by the terminal emulator process and cannot be opened from outside. The most practical solutions are: (1) run Claude Code inside tmux and use `send-keys`, (2) launch Claude Code in headless/SDK mode with stdin pipe for programmatic control, (3) use AppleScript/CGEvent to simulate keystrokes to the focused terminal window, or (4) use a custom PTY wrapper that exposes the master fd.

## Questions Answered

### Q1: How does tmux send-keys actually inject input?

**Answer:** Yes, tmux writes to the master side of the PTY. tmux owns the entire PTY lifecycle for each pane. When you create a pane, tmux calls `forkpty()` or equivalent, which returns the master file descriptor to the tmux server process and connects the slave to the child shell. The `send-keys` command flows through `cmd-send-keys.c` -> `input_key()` in `input-keys.c` -> `input_key_write()` which calls `bufferevent_write()` on the pane's event buffer, which ultimately writes to the master PTY file descriptor (`wp->event`). Since tmux IS the process that owns the master fd, it can freely write to it. The data written to the master appears as input on the slave side, which is what the shell/process reads from stdin.

**Source:** [tmux/cmd-send-keys.c](https://github.com/tmux/tmux/blob/master/cmd-send-keys.c), [tmux/input-keys.c](https://github.com/tmux/tmux/blob/master/input-keys.c), [tmux/window.c](https://github.com/tmux/tmux/blob/master/window.c)
**Confidence:** High

### Q2: Can you write to the master PTY from outside the terminal emulator?

**Answer:** No, not directly. The master PTY file descriptor is a process-local resource. When Terminal.app or VS Code calls `forkpty()`, it gets back a file descriptor number (e.g., fd 5) that only exists in that process's file descriptor table. There is no filesystem path to the master side -- `/dev/ttysXXX` is the SLAVE side. On Linux, you could theoretically use `/proc/PID/fd/N` to access another process's file descriptors, but macOS has no `/proc` filesystem. macOS does not provide any mechanism to open another process's file descriptors from outside (without debugger-level access like `task_for_pid` which requires SIP disabled or entitlements).

The only way to write to a master PTY is:
1. Be the process that created it (like tmux)
2. Have inherited or received the fd via fork/exec or Unix domain socket fd-passing
3. Use a debugger/injection to call write() within the target process (requires entitlements)

**Source:** [Pseudoterminal Wikipedia](https://en.wikipedia.org/wiki/Pseudoterminal), [PTY deep dive](http://www.rkoucha.fr/tech_corner/pty_pdip.html), [macOS PTY article](https://medium.com/@rajeshbolloju1/how-macos-pty-works-92334ab1ef99)
**Confidence:** High

### Q3: Can we use AppleScript/osascript to simulate keystrokes?

**Answer:** Yes, but with significant limitations. AppleScript can send keystrokes via System Events:

```bash
osascript -e 'tell application "System Events" to keystroke "hello world"'
osascript -e 'tell application "System Events" to keystroke return'
```

**Limitations:**
- Keystrokes go to the FRONTMOST application only -- you cannot target a background window
- You can activate a specific app first: `tell application "Terminal" to activate`, but this steals focus
- Requires Accessibility permissions in System Preferences
- There is no reliable way to target a specific Terminal tab/window without bringing it to front
- Claude Code uses Ink TUI which may handle programmatic Enter differently than physical keypresses (see issue #15553)

**Terminal.app also supports `do script`:**
```applescript
tell application "Terminal"
    do script "some text" in front window
end tell
```
But `do script` runs a NEW command -- it doesn't type into an existing interactive process. It's essentially equivalent to opening a new shell and running a command.

**Source:** [AppleScript System Events](https://en.wikibooks.org/wiki/AppleScript_Programming/System_Events), [Apple Community discussion](https://discussions.apple.com/thread/8581123), [Keyboard automation guide](https://eastmanreference.com/how-to-automate-your-keyboard-in-mac-os-x-with-applescript)
**Confidence:** High

### Q4: Does the `write` command work for this?

**Answer:** No. The Unix `write` command writes a message that appears on the OTHER user's terminal display -- it writes to the slave side of their PTY, which means the text shows up as OUTPUT on their screen. It does NOT inject the text as INPUT to whatever process is running on that terminal. This is exactly the same problem as writing to `/dev/ttysXXX` directly.

**Source:** [write(1) man page](https://linux.die.net/man/1/write), [Linux write command](https://phoenixnap.com/kb/write-command-in-linux)
**Confidence:** High

### Q5: Can we use CGEvent to simulate keyboard input?

**Answer:** Yes, CGEvent can simulate keyboard input, but with the same focus limitations as AppleScript:

```swift
// Create key down event for character 'a' (keycode 0)
let keyDown = CGEvent(keyboardEventSource: nil, virtualKey: 0x00, keyDown: true)
let keyUp = CGEvent(keyboardEventSource: nil, virtualKey: 0x00, keyDown: false)
keyDown?.post(tap: .cghidEventTap)
keyUp?.post(tap: .cghidEventTap)
```

**Limitations:**
- Events go to the frontmost/focused application
- `kCGAnnotatedSessionEventTap` can theoretically target specific apps, but documentation is sparse
- Requires Accessibility permissions
- Apps in the background do not receive CGEvent keyboard events
- Sandboxed apps cannot post CGEvents
- You need to map each character to a virtual keycode, which is keyboard-layout dependent

**Source:** [Apple Developer Forums](https://developer.apple.com/forums/thread/73639), [macOS keyboard event interception](https://www.logcg.com/en/archives/2902.html), [CGEventPost discussion](https://developer.apple.com/forums/thread/13459)
**Confidence:** High

### Q6: Can we use `expect` or `script` to inject input?

**Answer:** Only if you LAUNCH the process through expect/script -- you cannot attach to an already-running process.

**expect:** Creates its own PTY pair via `spawn`, holds the master fd, and uses `send` to write to it. But `spawn` starts a NEW process -- it cannot attach to an existing one.

**script:** Similarly creates a PTY wrapper around a command. The `script` command on macOS can wrap a process: `script -q /dev/null command_here`, giving you a PTY-wrapped process. But again, only at launch time.

**pexpect (Python):** Same pattern -- `pexpect.spawn()` creates a new process with a PTY. Cannot attach to existing.

**Source:** [expect man page](https://man7.org/linux/man-pages/man1/expect.1.html), [MacStadium expect guide](https://macstadium.com/blog/automating-interactive-processes-with-expect-on-macos), [Python pty docs](https://docs.python.org/3/library/pty.html)
**Confidence:** High

### Q7: Is there a /proc/PID/fd/0 equivalent on macOS?

**Answer:** No. macOS does not have a `/proc` filesystem. There is `/dev/fd/` but that refers to the CURRENT process's file descriptors, not another process's. There is no macOS equivalent to Linux's `/proc/PID/fd/0` that would let you write to another process's stdin from outside.

You can use `lsof -p PID` to SEE what file descriptors a process has open (and which device nodes they point to), but you cannot OPEN those same descriptors from another process.

**Source:** [lsof on macOS](https://til.simonwillison.net/macos/lsof-macos), [File descriptors guide](https://flylib.com/books/en/3.162.1.160/1/)
**Confidence:** High

### Q8: Claude Code CLI programmatic input mechanisms?

**Answer:** Claude Code has several programmatic interfaces, but none allow sending messages to an already-running interactive session:

**Headless/SDK Mode (recommended for programmatic use):**
```bash
# Single prompt (non-interactive)
claude -p "your prompt here"

# Multi-turn via stdin with stream-json
claude -p "initial prompt" \
  --input-format stream-json \
  --output-format stream-json \
  --verbose
```

With `--input-format stream-json`, you can pipe JSONL messages into stdin for multi-turn conversation. Each line is a JSON user message object. This is the officially supported way to programmatically interact with Claude Code.

**Session resume:**
```bash
# Continue most recent session
claude --continue -p "follow-up message"

# Resume specific session
claude --resume SESSION_ID -p "follow-up message"
```
But these launch a NEW CLI process -- they don't inject into a running one.

**Known limitations (from GitHub issues):**
- Issue #15553: Claude Code's Ink TUI treats programmatic `\r`/`\n` differently from physical Enter keypress. Programmatic newlines create newlines in the input box rather than submitting.
- Issue #2929: Request for IPC to programmatically drive running instances -- closed as duplicate, not implemented.
- Issue #16712: Request for providing tool_result via stdin when resuming -- not yet implemented.

**No IPC socket/file mechanism exists** for sending messages to a running Claude Code interactive session. The team has not implemented Unix sockets, named pipes, or any other IPC mechanism for this purpose.

**Source:** [Claude Code headless docs](https://code.claude.com/docs/en/headless), [Issue #15553](https://github.com/anthropics/claude-code/issues/15553), [Issue #2929](https://github.com/anthropics/claude-code/issues/2929), [Issue #16712](https://github.com/anthropics/claude-code/issues/16712)
**Confidence:** High

## Detailed Findings

### Finding 1: Why Writing to /dev/ttysXXX Doesn't Work

**Source:** [PTY deep dive](http://www.rkoucha.fr/tech_corner/pty_pdip.html), [Pseudoterminal Wikipedia](https://en.wikipedia.org/wiki/Pseudoterminal)

The PTY pair works like this:

```
[Terminal Emulator] --write--> [Master FD] --appears as input--> [Slave /dev/ttysXXX] --read by--> [Shell/Process stdin]
[Terminal Emulator] <--read--- [Master FD] <--appears as output-- [Slave /dev/ttysXXX] <--written by-- [Shell/Process stdout]
```

When you write to `/dev/ttysXXX` from an external process, you are writing to the SLAVE side. Data written to the slave appears as OUTPUT on the master side -- which means it shows up on the terminal screen. It does NOT get fed back as input to the process reading from the slave's stdin.

This is by design: the slave side is where the shell's stdout/stderr go. Writing to it from outside is equivalent to another process printing to the same terminal.

### Finding 2: tmux Architecture for Input Injection

**Source:** [tmux source code](https://github.com/tmux/tmux)

tmux's architecture:

```
[tmux client] --socket--> [tmux server] --master fd--> [PTY master] <==> [PTY slave] --> [shell/process]
```

1. tmux server calls `forkpty()` for each pane, getting back the master fd
2. The server stores this fd in the `window_pane` structure
3. `send-keys` command is received via the tmux socket protocol
4. Server looks up the target pane's `window_pane` struct
5. Calls `input_key()` which translates key names to bytes
6. `input_key_write()` calls `bufferevent_write()` on the pane's event buffer
7. The bufferevent writes to the master fd
8. The kernel PTY layer delivers this as input on the slave side
9. The shell/process reads it from stdin

The key insight: tmux works because it IS the terminal emulator -- it owns the master fd.

### Finding 3: Claude Code Headless/SDK Multi-Turn Pattern

**Source:** [Claude Code headless docs](https://code.claude.com/docs/en/headless), [Stream-JSON chaining](https://github.com/ruvnet/claude-flow/wiki/Stream-Chaining)

The officially supported programmatic pattern:

```bash
# Launch with stdin pipe for multi-turn
claude -p "initial prompt" \
  --input-format stream-json \
  --output-format stream-json \
  --verbose

# Then write JSONL messages to stdin:
# {"type":"user","content":"follow-up message"}
```

This keeps the process alive and accepts new user messages via stdin. The parent process holds the stdin pipe and can write to it at any time.

### Finding 4: Custom PTY Wrapper Approach

**Source:** [Python pty docs](https://docs.python.org/3/library/pty.html), [node-pty](https://github.com/microsoft/node-pty), [pexpect/ptyprocess](https://github.com/pexpect/ptyprocess)

You could build a wrapper that:
1. Creates a PTY pair (master + slave)
2. Launches Claude Code with the slave as its stdin/stdout/stderr
3. Exposes the master fd for both display AND input injection
4. Provides a side-channel (Unix socket, named pipe, HTTP) for receiving input to inject

```python
import pty, os, select, socket

master_fd, slave_fd = pty.openpty()
pid = os.fork()
if pid == 0:
    # Child: connect slave to stdin/stdout/stderr, exec claude
    os.close(master_fd)
    os.setsid()
    os.dup2(slave_fd, 0)  # stdin
    os.dup2(slave_fd, 1)  # stdout
    os.dup2(slave_fd, 2)  # stderr
    os.close(slave_fd)
    os.execvp("claude", ["claude"])
else:
    # Parent: holds master_fd
    # Can write to master_fd to inject input
    # Can read from master_fd to get output
    # Can also listen on a Unix socket for external input
    os.write(master_fd, b"hello world\r")
```

This is essentially what tmux does, but you'd build a simpler version focused on input injection.

### Finding 5: AppleScript Terminal.app "do script" Behavior

**Source:** [Apple Community](https://discussions.apple.com/thread/1738507), [Harvard guide](https://hea-www.harvard.edu/~fine/OSX/terminal-tabs.html)

`do script` in Terminal.app works differently than expected:
- It sends the text as if typed, followed by a newline
- It goes through the terminal emulator's normal input path
- It DOES write to the master PTY (Terminal.app owns the master)

```applescript
tell application "Terminal"
    -- Send text to the front window's current session
    do script "your text here" in front window
end tell
```

**IMPORTANT CAVEAT:** `do script` is designed for running shell commands. When used with an interactive TUI app like Claude Code:
- It sends the text followed by a carriage return
- But Claude Code's Ink-based TUI intercepts raw terminal input at a lower level
- The Enter key from `do script` may be interpreted differently than a physical keypress
- Testing is needed to confirm whether this actually submits in Claude Code's input field

## Comparison Matrix

| Approach | Works on macOS Sequoia | Targets Specific Window | No Focus Steal | Works with Running Process | Complexity |
|----------|----------------------|------------------------|----------------|---------------------------|------------|
| tmux send-keys | Yes | Yes | Yes | Yes (if in tmux) | Low |
| Claude Code SDK/headless | Yes | N/A | Yes | Must launch this way | Low |
| AppleScript keystroke | Yes | No (frontmost only) | No | Yes | Low |
| AppleScript do script | Yes | Yes (specific window) | Yes | Yes (but may not work with TUI) | Low |
| CGEvent keyboard | Yes | No (frontmost only) | No | Yes | Medium |
| Custom PTY wrapper | Yes | N/A | Yes | Must launch this way | High |
| expect/pexpect | Yes | N/A | Yes | Must launch this way | Medium |
| Write to /dev/ttysXXX | N/A | N/A | N/A | **Does not work** (output, not input) | N/A |
| TIOCSTI | **Disabled on macOS** | N/A | N/A | N/A | N/A |
| /proc/PID/fd/0 | **Does not exist on macOS** | N/A | N/A | N/A | N/A |
| Unix `write` command | N/A | N/A | N/A | **Does not work** (same as /dev/ttysXXX) | N/A |

## Recommendations

### Recommended Approach 1: Claude Code Headless/SDK Mode (Best for programmatic control)

If the goal is programmatic control of Claude Code, launch it in headless mode with a stdin pipe:

```bash
# From the macOS app, spawn:
claude -p "initial prompt" \
  --input-format stream-json \
  --output-format stream-json \
  --verbose
```

Then write JSONL user messages to its stdin from the parent process. This is the officially supported pattern and avoids all the PTY complexity.

**Pros:** Officially supported, clean API, no focus issues, no accessibility permissions needed
**Cons:** No interactive TUI (you'd need to build your own UI), must launch Claude Code this way from the start

### Recommended Approach 2: tmux send-keys (Best for interactive TUI)

If you need the interactive TUI visible in a terminal:

```bash
# Create tmux session
tmux new-session -d -s claude-session "claude"

# Send input from your app
tmux send-keys -t claude-session "your message here" Enter
```

**Pros:** Reliable, well-tested, works with TUI, no focus stealing, targets specific pane
**Cons:** Requires tmux as a dependency, adds architectural complexity

### Recommended Approach 3: Custom PTY Wrapper (Most flexible)

Build a small daemon/wrapper that:
1. Creates a PTY pair
2. Launches Claude Code on the slave side
3. Listens on a Unix socket for input injection commands
4. Writes received input to the master fd
5. Forwards master output to the terminal for display

This gives you the best of both worlds: interactive TUI display AND programmatic input injection.

Could be implemented in Python (~50 lines), Swift, or Node.js (using node-pty).

**Pros:** Full control, no tmux dependency, works with any terminal
**Cons:** Must build and maintain the wrapper, moderate complexity

### Recommended Approach 4: AppleScript do script (Quick hack, unreliable)

```bash
osascript -e 'tell application "Terminal" to do script "message text" in front window'
```

**Pros:** Simple, one-liner, uses Terminal.app's own master PTY
**Cons:** May not work correctly with Claude Code's TUI, appends newline automatically, uncertain behavior with Ink-based input handling

## Implementation Notes

- **TIOCSTI is dead on macOS**: Do not pursue this path. It was disabled for security reasons and will not come back.
- **Writing to /dev/ttysXXX will never work for input**: This is a fundamental PTY architecture constraint, not a permissions issue.
- **Claude Code Issue #15553 is the exact problem**: The Ink TUI framework treats programmatic Enter differently from physical keypresses. Even if you successfully inject `\r` via the master PTY, the Ink component may interpret it as a newline rather than a submit action. tmux send-keys works because it injects at the same level as physical keypresses (pre-Ink processing).
- **Accessibility permissions**: Any CGEvent or AppleScript keystroke approach requires the calling app to have Accessibility permissions in System Preferences > Privacy & Security.
- **macOS Sequoia hardening**: macOS continues to restrict low-level input injection mechanisms. Design for the supported paths (tmux, headless mode, AppleScript with permissions) rather than trying to bypass security.

## Sources

1. [tmux send-keys source code](https://github.com/tmux/tmux/blob/master/cmd-send-keys.c) - How tmux implements key injection
2. [tmux input-keys.c](https://github.com/tmux/tmux/blob/master/input-keys.c) - Key translation and writing to master PTY
3. [Pseudoterminal Wikipedia](https://en.wikipedia.org/wiki/Pseudoterminal) - PTY architecture overview
4. [PTY deep dive](http://www.rkoucha.fr/tech_corner/pty_pdip.html) - Comprehensive PTY programming guide
5. [macOS PTY article](https://medium.com/@rajeshbolloju1/how-macos-pty-works-92334ab1ef99) - macOS-specific PTY behavior
6. [Claude Code headless docs](https://code.claude.com/docs/en/headless) - Official programmatic usage documentation
7. [Issue #15553: Programmatic Input Submission](https://github.com/anthropics/claude-code/issues/15553) - Feature request for input injection
8. [Issue #2929: Programmatically drive instances](https://github.com/anthropics/claude-code/issues/2929) - IPC feature request
9. [Issue #16712: tool_result via stdin](https://github.com/anthropics/claude-code/issues/16712) - stdin input for resumed sessions
10. [node-pty](https://github.com/microsoft/node-pty) - Node.js PTY bindings (used by VS Code)
11. [Python pty module](https://docs.python.org/3/library/pty.html) - Python pseudo-terminal utilities
12. [AppleScript System Events](https://en.wikibooks.org/wiki/AppleScript_Programming/System_Events) - Keystroke automation
13. [Apple Developer Forums: CGEvent](https://developer.apple.com/forums/thread/73639) - CGEvent keyboard simulation
14. [lsof on macOS](https://til.simonwillison.net/macos/lsof-macos) - File descriptor inspection
15. [TIOCSTI insecurity](https://undeadly.org/cgi?action=article;sid=20170701132619) - Why TIOCSTI was disabled
16. [expect automating on macOS](https://macstadium.com/blog/automating-interactive-processes-with-expect-on-macos) - expect usage patterns

## Open Questions

- Will Apple ever provide a sanctioned API for inter-process terminal input injection? (Unlikely given the security trend)
- Will Claude Code implement Issue #15553 (IPC socket for programmatic input)? This would be the ideal solution.
- Does `Terminal.app do script` actually work with Claude Code's Ink TUI for submitting prompts? Needs testing.
- Could `tmux control mode` (-CC) provide a cleaner integration path than send-keys for macOS apps?
